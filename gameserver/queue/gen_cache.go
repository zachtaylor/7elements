// Code generated by go-gengen(v0.0.2) DO NOT EDIT.

package queue

import (
	"sync"
)

// Cache is an observable concurrent in-memory datastore
type Cache struct {
	dat   map[string]*T
	mu    sync.Mutex
	obs   []Setter
}

// Storer is an abstraction of in-memory datastore
type Storer interface {
	Get(string) *T
	Set(string, *T)
	Each(Setter)
	Sync(func(Getter, Setter))
	Keys() []string
	Observe(Setter)
	Remove(string)
}

// Getter is a k->v func
type Getter = func(string) *T

// Setter is a k,v func
type Setter = func(string, *T)

// NewCache returns a new Cache
func NewCache() *Cache {
	return &Cache{
		dat: make(map[string]*T),
		obs:   make([]Setter, 0),
	}
}

// Get returns the *T for a string
func (c *Cache) Get(k string) *T { return c.dat[k] }

// Set saves a *T for a string
func (c *Cache) Set(k string, v *T) {
	c.mu.Lock()
	c.set(k, v)
	c.mu.Unlock()
}

func (c *Cache) set(k string, v *T) {
	if v != nil {
		c.dat[k] = v
	} else {
		delete(c.dat, k)
	}
	for _, f := range c.obs {
		f(k, v)
	}
}

// Each calls the func for each string,*T in this Cache
func (c *Cache) Each(f Setter) {
	c.mu.Lock()
	for k, v := range c.dat {
		f(k, v)
	}
	c.mu.Unlock()
}

// Sync calls the func within the cache lock state
func (c *Cache) Sync(f func(Getter, Setter)) {
	c.mu.Lock()
	f(c.Get, c.set)
	c.mu.Unlock()
}

// Keys returns a new slice with all the string keys
func (c *Cache) Keys() []string {
	c.mu.Lock()
	keys := make([]string, 0, len(c.dat))
	for k := range c.dat {
		keys = append(keys, k)
	}
	c.mu.Unlock()
	return keys
}

// Observe adds a func to be called when a *T is explicitly set
func (c *Cache) Observe(f Setter) { c.obs = append(c.obs, f) }

// Remove deletes a string,*T
func (c *Cache) Remove(k string) { c.Set(k, nil) }
